require 'optparse'
require 'yaml'
require 'erb'
require 'time'
require_relative '../lib/metababel/bt2_trace_class_generator'

REGEXT_PRETTY = /
 =\s            # We are interested to the right of the equal sign
 (
    ""|         # Empty string
    ".*?[^\\]"| # String who can contain space and quoted string
    [^\s,]+     # Anything except space and comma
 )
/x

REGEXT_EVENT = /
  (?:\[(\S+)\]    # Timestamp
  \s
  \(\S+\)\s)      # Offset
  ?(\S+):         # Event
  \s
  (?:{(.*)})?     # Common data, payload
/x

SOURCE_TEMPLATE = <<~TEXT
  /* Code generated by #{__FILE__} */

  #include <metababel/metababel.h>
  #include <stdbool.h>

  void btx_push_usr_messages(void *btx_handle, void *usr_data, btx_source_status_t *status) {
      <%- data.each do | entry | -%>
      <%- entry.fetch(:times,1).times do -%>
      btx_push_message_<%= entry[:name] %>(btx_handle<%= ', ' if not entry[:field_values].empty? %><%= entry[:field_values].join(", ") %>);
      <%- end -%>
      <%- end -%>
      *status = BTX_SOURCE_END;
  }

  void btx_register_usr_callbacks(void *btx_handle) {
    btx_register_callbacks_push_usr_messages(btx_handle, &btx_push_usr_messages);
  }
TEXT

class Babeltrace2Gen::BTTraceClass
  def find_event_class
    @stream_classes.map do |s|
      s.event_classes.map.with_index do |e|
        return e if yield(e)
      end
    end.flatten
  end
end

def sanitize_value(field_value, field_type)
  return field_value unless field_type

  case field_type
  when 'int64_t', 'int32_t'
    "INT#{field_type[3,2]}_C(#{field_value})"
  when 'uint64_t', 'uint32_t'
    "UINT#{field_type[4,2]}_C(#{field_value})"
  else
    field_value
  end
end

def parse_log(input_path, yaml_path = nil)
  trace = yaml_path ? Babeltrace2Gen::BTTraceClass.from_h(nil, YAML.load_file(yaml_path)) : nil

  File.open(input_path, 'r') do |file|
    file.each_line.map do |line|
      match = line.match(REGEXT_EVENT)
      raise "Unsupported format for '#{line}'." unless match

      timestamp, head, tail = match.captures
      ts = nil
      if timestamp
        t = Time.parse(timestamp)
        # Need to convert in nasosecond
        ts = t.to_i * 1_000_000_000 + t.nsec
      end

      event_name = head
      field_values = tail.nil? ? [] : tail.scan(REGEXT_PRETTY).flatten

      if trace
        event_args = {}
        event = trace.find_event_class { |e| e.name == event_name }
        raise "Event '#{event_name}' not found" unless event
        event.get_getter(event: 'event', arg_variables: event_args)
        field_values = field_values.zip(
          event_args.fetch('outputs',[]).map(&:type)).map { |value, type| sanitize_value(value, type) }
      end

      data = {
        name: event_name.gsub(/[^0-9A-Za-z-]/, '_'), # Should reuse metababel mangling
        field_values: [ts,field_values].compact.flatten(1)
      }
    end
  end
end

def render_and_save(data, output_path)
  renderer = ERB.new(SOURCE_TEMPLATE, trim_mode: '-')
  output = renderer.result(binding)
  File.write(output_path, output, mode: 'w')
end

DOCS = <<-DOCS
  Usage: #{$0}.rb [options]

  Example:
    ruby #{$0} -y stream_classes.yaml -i btx_log.txt -o callbacks.c
DOCS

# Display help if no arguments.
ARGV << '-h' if ARGV.empty?

options = {}

OptionParser.new do |opts|
  opts.banner = DOCS

  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end

  opts.on('-y', '--yaml PATH', '[Mandatory] Path to btx_model.yaml.') do |p|
    options[:yaml_path] = p
  end

  opts.on('-i', '--log PATH', '[Mandatory] Path to btx_log.txt.') do |p|
    options[:input_path] = p
  end

  opts.on('-o', '--output PATH', '[Mandatory] Path to the bt2 SOURCE file.') do |p|
    options[:output_path] = p
  end
end.parse!

raise OptionParser::MissingArgument if options[:output_path].nil?

data = options.key?(:input_path) ? parse_log(options[:input_path], options[:yaml_path]) : []
render_and_save(data, options[:output_path])
